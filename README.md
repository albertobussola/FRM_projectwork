# FRM_projectwork
FRM_projectwork

con @esposito @marchesi @pinna CREDIT SUPPORT ANNEX La classe di partenza. Abbiamo definito i campi dell’oggetto CreditSupportAnnex come Threshold posting e receiving, Minimum Transfer Amount posting e receiving.

COUNTERPARTY EXPOSURE AGGREGATION Questa classe vanta un particolare metodo, calculate(), nel quale si va a determinare il netting di un portafoglio. Abbiamo definito RandomVariable[] nettingValue di lunghezza pari alla discretizzazione del tempo e inizializzato a 0. Siamo andati ora a scorrere tutti i trade nel portafoglio e per ognuno di questi abbiamo ricavato la Surface contenuta nel Container, per fare ciò abbiamo utilizzato la FactorKey per i trade. Per ogni trade ora abbiamo preso il valore di ogni discretizzazione temporale, ovvero nella posizione i-esima, e lo abbiamo inserita, con il metodo add(), al relativo tempo nella nostra nettingValue che allo scorrere dei vari trade creerà alla fine il netting ad ogni istante temporale. Una volta finite le operazioni sui trades abbiamo creato la Surface cptyValueSurface sulla base di nettingValue. Infine abbiamo creato un ‘nuovo’ SurfaceContainer, che non è altro che la copia di quello attuale con l’aggiunta di questa nuova cptyValueSurface. Il metodo restituisce un oggetto CounterpartyExposureAggregation con SurfaceContainer contenente cptyValueSurface, ovvero la nostra superficie col netting di portafoglio.

COLLATERAL SIMULATION Anche in questa classe abbiamo implementato il metodo calculate(), per il calcolo del collaterale di portafoglio. In questo caso facciamo uso di 3 array con lunghezza pari alla discretizzazione del tempo del tipo RandomVariable: collateralBalance, positiveCollateralBalance, negativeCollateralBalance. Tramite la FactorKey ci ricaviamo la Surface che abbiamo chiamato valueSurface contenente il netting, calcolato nella classe precedente, da cui estrapoliamo valueSlice, ovvero il RandomVariable array che contiene i valori del netting. Con il ciclo for per ogni discretizzazione del tempo andiamo a calcolare: ● positiveCollateralBalance: aggiungendo {+ ThresholdPost + 0.5MTAPost} a valueSlice con il metodo add() a cui poi applicheremo il metodo cap() che prende il valore minimo tra l’oggetto a cui si applica il metodo e il parametro dato, nel nostro caso 0. ● negativeCollateralBalance: aggiungiamo {- ThresholdRec - 0.5MTARec} sempre con add() e poi applichiamo il metodo floor() che prende il max tra l’oggetto e il nostro parametro, 0. ● collateralBalance: risultato della somma tra positiveCollateralBalance e negativeCollateralBalance. Per concludere la classe creiamo tre nuove Surface positiveCollateralSimulation, negativeCollateralSimulation e collateralSimulation e le aggiungiamo ad un nuova copia del nostro SurfaceContainer. Il metodo ritorna un oggetto CollateralSimulation contenente il SurfaceContainer arricchito del collaterale.

POST COLLATERAL EXPOSURE AGGREGATION Anche per questa classe, essendo figlia dell’interfaccia RiskCalcultion come le precedenti due, abbiamo compilato il metodo calculate() nel quale abbaimo creato e inizializzato i tre array di RandomVariable: postCollateralExposure, positivePostCollateralExposure e negativePostCollateralExposure. Ci siamo quindi ricavati tramite le due FactorKey collKey e valueKey e un booleano isCollateralized, che ci permetterà di differenziare il processo tra portafoglio collateralizzato e non. Se il portafogli è collateralizzato e quindi entriamo nell’ if , per ogni istante di tempo ci ricaviamo la superficie e i valori del portafoglio collateralizzato che salviamo in collateralSlice, ed insieme a valueSlice ci troviamo: ● postCollateralExposure: come Vt - Ct tramite il metodo sub(); ● positivePostCollateralExposure: come max{Vt – Ct, 0} con il metodo floor(); ● negativePostCollateralExposure: come max{Ct – Vt, 0} con il metodo floor(). Nel caso in cui invece il portafoglio non fosse collateralizzato, troviamo ● positivePostCollateralExposure: come max{Vt, 0} con il metodo floor(); ● negativePostCollateralExposure: come max{– Vt, 0} con il metodo floor(). Quindi ora come fatto nelle classi in precedenza andiamo ad aggiungere i risultati nelle relative Surface: positiveExposureSurface, negativeExposureSurface e postCollateralExposureSurface. Queste vengono poi aggiunte al nuovo clone del SurfaceContainer. Il metodo ritorna quindi l’oggetto PostCollateralSimulation contenente, tra gli altri campi, il SurfaceContainer arricchito.

EXPOSURE TEST Inizialmente abbiamo creato un nuovo CreditSupportAnnex csa coi parametri richiesti di Threshold Post/Rec e MTA Post/Rec. Per l’Esercizio 2 abbiamo creato un CounterPartyExposureAggregation cea e con il comando cea.calculate() otteniamo una Surface, valueSurface, contenente i valori del portafoglio, composto da un singolo swap, e la aggiungiamo al cubo markToMarketCube. Procediamo similmente per ricavarci le Surface del collaterale collateralSurface e poi quella dell’esposizione postCollateralSurface data dalla differenza tra valore dello stesso e collaterale. Per lo studio del quantile al 95% ci siamo adoperati di 3 double[] : quantileBeforeCollateral, quantileAfterCollateral e quantilePostExp., i quali contengono rispettivamente i valori ricavati da valueSurface, collateralSurface e postCollateralSurface. Scorrendo per ogni istante di tempo abbiamo applicato il metodo getQuantile() a valueSurface , collateralSurface e al postCollateralSurface; possiamo vedere i risultati ottenuti tramite la stampa a video ‘ordinata’ (righe 370-388). Osserviamo come la Potential Future Exposure con un livello di confidenza del 95% sia notevolmente ridotta, se non azzerata, con l’introduzione del collaterale. Possiamo anche riscontrare l’effetto del collaterale abbiamo ricreato l’andamento graficamente con l’utilizzo di Excel per motivi pratici (figura 1). Per l’Esercizio 3 abbiamo introdotto altri 2 swap di segno opposto al primo, entrambi con nozionale di 750000€ e che pagano tasso fisso di 0.035, il primo, e 0.02, il secondo. Abbiamo quindi costruito l’insieme dei trade relativi ai nuovi swap e inseriti nel nostro portafoglio, ed ora facciamo le stesse procedure utilizzate nell’Esercizio 2, però saranno relative ad un portafoglio con più di uno strumento al suo interno, così da poter andare a studiare l’effetto del netting. Per verificare l’effetto positivo di quest’ultimo abbiamo anche calcolato l’esposizione senza netting, ovvero abbiamo creato un ciclo for che scorre su tutti i trade e come per l’Esercizio 2 trova l’esposizione di ogni singolo trade che andremo a sommare per ottenere l’esposizione complessiva, che abbiamo salvato in un double[] chiamato noNetting. All’interno dello stesso ciclo troviamo anche i valori ricavati per l’Esercizio 2 che a causa della modifica del portafoglio iniziale, di uno swap, abbiamo ritenuto conveniente trovare nuovamente per non appesantire e rendere ripetitivo il codice. Vediamo poi i risultati ottenuti dalle esposizioni con e senza netting, prima con una stampa a video ‘ordinata’ (righe 393-403) e successivamente con l’aiuto della grafica tramite un grafico. Similmente a quanto fatto prima stampiamo a video il confronto tra netting (figura 2) e non e osserviamo come la possibilità di aggregare le posizioni renda il portafoglio notevolmente meno esposto grazie anche all’aiuto del grafico finale (figura 3).
